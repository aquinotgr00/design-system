import{m as y,ac as f,T as A,al as C,V as F,r as l,c as S,a1 as V,_ as x,J as b,x as _,p as P,N as g,B as E,q as B}from"./framework.f3d2a0a5.js";import{f as $}from"./vnode.534ed3f0.js";import{u as O}from"./index.4926e9c0.js";import{u as X}from"./index.b33282b2.js";import{r as k}from"./hook.64405bb6.js";import{A as j,s as q}from"./theme.6d4ed01a.js";function v(){}const z=y({props:{active:{type:Number,default:0},keepAlive:{type:Boolean,default:!1},transition:{type:String,default:"slide-left"}},setup(e,{slots:s}){return()=>{const a=$(s.default(),"Step").at(e.active),i=()=>e.keepAlive?f(C,()=>f(a,{key:e.active})):f(a,{key:e.active});return f(A,{name:e.transition,mode:"out-in"},i)}}}),h=Symbol("STEPS_CONTEXT");function I(){const e=F(h,()=>(console.warn("<p-step> must be placed inside <p-steps>"),{next:v,prev:v,toStep:v,step:l(1),canPrev:l(!1),canNext:l(!1),onPrevHooks:l([]),onNextHooks:l([])}),!0),s=l([]),a=l([]);function i(t){s.value.unshift(t)}function n(t){a.value.unshift(t)}const r=async(...t)=>await k(s.value,...t),o=async(...t)=>await k(a.value,...t);return e.onPrevHooks.value.unshift(r),e.onNextHooks.value.unshift(o),j(()=>{const t=e.onPrevHooks.value.indexOf(r),u=e.onNextHooks.value.indexOf(o);t>-1&&e.onPrevHooks.value.splice(t,1),u>-1&&e.onNextHooks.value.splice(u,1)}),{...e,onBeforePrev:i,onBeforeNext:n}}const J=y({components:{StepSlider:z},props:{modelValue:{type:Number,default:1},keepAlive:{type:Boolean,default:!1},direction:{type:String,default:"horizontal"},loop:{type:Boolean,default:!1},animation:{type:String,default:"slide"},onBeforePrev:{type:Function,default:()=>!0},onBeforeNext:{type:Function,default:()=>!0},onFinished:{type:Function,default:v}},models:{prop:"modelValue",event:"update:modelValue"},emits:["update:modelValue"],setup(e,{slots:s}){const a=l([e.onBeforeNext]),i=l([e.onBeforePrev]),n=O(e),r=l(e.direction==="vertical"?"slide-top":"slide-left"),o=S(()=>$(s.default(),"Step").length),t=X(n,1,o),u=S(()=>e.loop||n.value<=o.value),N=S(()=>e.loop||n.value>1);async function H(){u.value&&await p(n.value+1)}async function T(){N.value&&await p(n.value-1)}async function p(c){const d=n.value,w=c>d?a.value:i.value,m=e.loop?((c-1)%o.value+o.value)%o.value+1:c;await k(w,m,d)&&(m<=o.value?(r.value=c>d?e.direction==="vertical"?`${e.animation}-top`:`${e.animation}-left`:e.direction==="vertical"?`${e.animation}-bottom`:`${e.animation}-right`,t.value=m):await e.onFinished())}return q(t,n),V(h,{step:t,next:H,prev:T,canNext:u,canPrev:N,toStep:p,onPrevHooks:i,onNextHooks:a}),{transition:r,step:t}}});const K={class:"steps","data-testid":"steps"};function M(e,s,a,i,n,r){const o=b("StepSlider");return _(),P("div",K,[g(o,{active:e.step-1,"keep-alive":e.keepAlive,transition:e.transition},{default:E(()=>[B(e.$slots,"default")]),_:3},8,["active","keep-alive","transition"])])}const ee=x(J,[["render",M]]),R=y({name:"Step",props:{onBeforePrev:{type:Function,default:()=>!0},onBeforeNext:{type:Function,default:()=>!0}},setup(e){const{canNext:s,canPrev:a,toStep:i,step:n,next:r,prev:o,onBeforeNext:t,onBeforePrev:u}=I();return t(e.onBeforeNext),u(e.onBeforePrev),{canNext:s,canPrev:a,toStep:i,prev:o,next:r,step:n}}}),U={class:"step","data-testid":"step"};function D(e,s,a,i,n,r){return _(),P("div",U,[B(e.$slots,"default",{step:e.step,next:e.next,prev:e.prev,canPrev:e.canPrev,canNext:e.canNext,toStep:e.toStep})])}const te=x(R,[["render",D]]);export{ee as S,te as a};
